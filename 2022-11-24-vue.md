---
title:  "vue의 탄생"
search: false
categories: 
  - Vue
toc: true  
last_modified_at: 2022-11-24T10:06:00-05:00
tags:
  - Vue
author: 최혜정
---

# Intro
안녕하세요. 최혜정 사원입니다.
Vue 강의를 듣고 Vue의 탄생에 대해서 적어보려고 합니다.  


# 1. Vue 탄생


# 2. Vue, React, Angular 비교

## 1. Vue와 Angular는 프레임워크이며, React는 라이브러리이다.
  - 라이브러리는 사용자가 필요할 때에 가져다 썼다 뺐다 할 수 있고 부분적으로 사용이 가능하다.
  - 프레임워크는 부분적 사용이 불가능하고 프레임워크 안으로 들어가서 프레임워크가 지원해주는 문법에 따라서 작성해줘야 한다.
  - 프레임워크는 짜여진 패턴이나 틀 기반에서 내가 코딩을 하는 것이고, 라이브러리는 내가 가져다 사용해서 자유롭게 사용하는 방식이다.
  - 따라서 React 는 자유도가 높으며, Vue 는 한 가지 방식대로 한다.

## 2. 컴포넌트 분리 작업
  - Angular의 컴포넌트 코드는 총 4가지가 한 세트로 구성된다.
    - 템플릿 (app.component.html) - HTML로 컴포넌트 템플릿을 작성
    - 스타일 (app.component.css) - 이 컴포넌트에만 적용되는 CSS 스타일 작성
    - 컴포넌트 클래스 (app.component.ts) - TypeScript로 컴포넌트 클래스 코드 작성
    - 스펙 (app.component.spec.ts) - 클래스 파일을 테스트하는 파일       
  - React는 컴포넌트 분리할 때 한 개의 파일에서 여러 컴포넌트를 만들어 줄 수 있다.
  - 즉, 한 군데에서만 사용될 자식 컴포넌트를 정의 할 때, 같은 파일 내에 구현을 해놓고 사용하면 부모 컴포넌트에 의존한다는 것이 명백하게 드러난다.
  - Vue에서 새로운 컴포넌트를 분리하려면 일단 새로운 파일을 하나 더 만들어야하고, 그에 따라 하나의 파일에 해당하는 template, script, style 도 작성해야 합니다.
  
## 3. 데이터 바인딩
- 화면상에 보여지는 데이터(View)와 브라우저 메모리에 있는 데이터(Model)를 묶어서(Binding) 서로 간의 데이터를 동기화하는 것을 의미한다.
- Vue와 Angular는 선택적 데이터 바인딩 지원으로 단반향과 양방향을 선택할 수 있고, React는 단방향 데이터 바인딩이다.

### 3-1. 양방향 데이터 바인딩
- Model과 view가 연결되어있어 데이터 값이 한쪽에서 변화하면 다른쪽에서도 바로 업데이트가 진행된다.     

  • 장점: 코드의 양이 줄어든다. -> 데이터가 자동으로 변경되기 때문에  
  • 단점: 변화에 따라 DOM 객체 전체를 렌더링해주거나 데이터를 바꿔주므로, 성능이 감소되는 경우가 있다.
 
### 3-2. 단방향 데이터 바인딩
- 한쪽 방향으로만 제어가 가능한 것을 의미한다.      

  • 장점: 데이터 흐름이 단방향(부모->하위 컴포넌트)이라, 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉽다.    
  • 단점: 변화를 감지하고 화면을 업데이트 하는 코드를 매번 작성해야한다.

**Vue와 Angular는 선택적 데이터 바인딩 지원으로 단반향과 양방향을 선택할 수 있고, React는 단방향 데이터 바인딩이다.**

# 4. Virtual DOM
- React와 Vue는 Virtual DOM을 사용하고, Angular는 Incremental DOM을 사용한다.

## 4-1. Incremental DOM이란?
실제 DOM을 사용하여 코드의 변경 사항을 찾는 방식
- 모든 컴포넌트는 일련의 명령으로 컴파일 된다. 이 명령들은 데이터가 변경될 때 그 자리에서 DOM 트리를 만들고 업데이트 한다.

## 4-2. Virtual DOM이란?
실제 DOM을 가상화한 객체로, 실제 DOM 객체에 접근하여 조작하는 대신 이 가상의 DOM 객체에 접근하여 변화 전과 변화 후를 바교하고 바뀐 부분을 적용한다.
- DOM이 생성되기 전, 이전 상태 값과 수정사항을 비교하여 달라진 부분만 DOM에게 한 번에 전달하여 딱 한 번만 렌더링을 진행한다.
- 속도 저하를 예방할 수 있다.

## 4-3. Virtual DOM 동작 방식
1. 새로운 요소가 UI에 추가되면 전체 UI를 Virtual DOM에 렌더링 한다.
2. 현재 Virtual DOM과 이전 Virtual DOM을 비교해 차이를 계산한다. (가상 돔 끼리 비교)
3. 변경된 부분을 실제 DOM에 반영한다.

# 5. Vue2 & Vue3 차이점

## 5-1. Creating App의 차이
#### Vue2
```javascript
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h => h(App),
}).$mount('#app')
```

#### Vue3
```javascript
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

createApp(App).mount('#app')
```

### 5-2. Multiple Root
- Vue2에서는 template 안에 root node가 하나만 있어야 했다.
- 
#### Vue2
```html
<template>
  <div>
      <p>안녕</p>
      <button>하이</button>
  </div>
</template> 
```

#### Vue3
```html
<template>
  <p>안녕</p>
  <button>하이</button>
</template>
```

### 5-3. Options API & Composition API
- Options API에서는 data, computed, methods 등 데이터의 변화에 관련된 로직이 각각 흩어져 있다.
- Composition API는 setup() 이라는 메서드 안에서 이들을 그룹핑하므로 데이터의 흐름을 쉽게 파악하고 유지보수가 용이해진다.

#### Vue2
```javascript
<template>
  <div>
    <h1>{{ countWithUnit }}</h1>
    <button @click="increase">Increase</button>
    <button @click="decrease">Decrease</button>
  </div>
</template>

<script>
export default {
  data () {
    return {
      count: 0
    }
  },
  computed: {
    countWithUnit () {
      return this.count + '입니다.'
    }
  },
  methods: {
    increase () {
      ++this.count
    },
    decrease () {
      --this.count
    }
  }
}
</script>
```
- 카운터의 값을 저장하는 count
- 값을 조작하기 위한 증가(increase), 감소(decrease) 메소드
- 계산된 속성(computed)

#### Vue3
```javascript
<template>
  <div>
    <h1>{{ countWithUnit }}</h1>
    <button @click="increase">Increase</button>
    <button @click="decrease">Decrease</button>
  </div>
</template>

<script>
import { ref, computed } from '@vue/composition-api'

const useCount = () => {
  const count = ref(0)
  const countWithUnit = computed(() => count.value + ' 입니다')
  
  const increase = () => ++count.value
  const decrease = () => --count.value
  
  return { countWithUnit, increase, decrease }
}

export default {
  setup () {
    const { countWithUnit, increase, decrease } = countWithUnit()
    
    return {
      countWithUnit,
      increase,
      decrease
    }
  }
}
</script>
```

- 카운터 기능에 대한 값과 로직이 useCount 함수 내에 모두 모여있다.
- Vue component가 생성되기 전에 필요한 것들을 setup 한다.
- Options API 와 다르게 Composition API 에서는 setup() 함수 내부에 data 속성과 method, lifeCycle hook, watch 를 입력한다.
- 그 다음 setup() 함수내에서 생성한 함수들을 return 해주어야 해당 함수들을 사용할 수 있다.
- setup() 함수 내에서는 this의 사용이 불가능하다.

#### ref()
- 기본 자료형 변수를 반응형 객체로 변경한다.
- value 속성을 통해 접근할 수 있으며, 값을 변경할 때에도 value 속성에 접근하여 조작한다.
- setup() 안에서 사용할 때는 value 속성으로 접근해야하지만, return 키워드로 반환할 때는 자동으로 래핑이 해제되어 value를사용하지 않아도 된다.



![캡처1](./core/image/캡처1.PNG)  
로그 추적 로직이 부가기능이다. 그런데 이 부가기능을 여러 곳에서 공통으로 사용하면 각 핵심기능마다 부가기능을 추가해줘야한다.  
이 경우 코드의 중복이 발생하고, 핵심과 부가기능이 공존하기 때문에 유지보수가 어렵다.  

![캡처2](./core/image/캡처2.PNG)  
이러한 부가 기능은 **횡단 관심사**(cross-cutting concerns)가 된다.  **즉, 하나의 부가 기능이 여러 곳에 동일하게 사용된다는 뜻이다.**

그런데 로그찍는 방법이 달라졌는데 컴포넌트가 100개가 넘는다면 100개가 넘는 로직를 뜯어고쳐야한다.   
해결방법 -> 이 공통 부가기능인 횡단 관심사를 핵심기능과 완전히 분리하고자 하는 취지에서 나온것이 AOP 개념이다.  

![AOP](./core/image/AOP.PNG) 

부가기능을 각각의 코드에 넣기보다 따로 빼서 관리하는 것이 유지보수면에서 효율적이다.   
그래서 이 **"부가기능"과 "부가기능을 어디에 적용할지 선택하는 기능"을 합쳐서 하나의 모듈**로 만들었는데, 이것이 **Aspect**이다.   

이렇게 Aspect를 사용한 프로그래밍 방식을 관점 지향 프로그래밍 AOP(Aspect-Oriented Programming)라고 한다.

## 2-1. AOP 적용 방식
