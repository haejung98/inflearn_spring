# 스프링 핵심원리 - 기본편 정리
**https://www.inflearn.com/course/스프링-핵심-원리-기본편/dashboard**
 
안녕하세요. 오픈오브젝트 최혜정입니다.  
인프런 스프링 핵심원리 기본편을 수강하고 정리한 내용을 적어보려고 합니다.   

**[참고] 작성자는 Windows, STS 환경에서 따라해보았습니다.**  


## 프로젝트 생성

- 스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성  
    https://start.spring.io
 
- 프로젝트 선택
  - Project: Gradle Project
  - Spring Boot: 2.6.2
  - Language: Java
  - Packaging: Jar
  - Java: 11  
 
- Project Metadata  
  - groupId: hello
  - artifactId: core  
- Dependencies: 선택하지 않는다.

- build.gradle에 롬복 라이브러리 추가  
  - sts 기준 라이브러리 추가 후 build.gradle 파일에서 우클릭 후 "Gradle" -> "refresh gradle project"을 실행

  ```
  plugins {
   id 'org.springframework.boot' version '2.3.2.RELEASE'
   id 'io.spring.dependency-management' version '1.0.9.RELEASE'
   id 'java'
  }
  
  group = 'hello'
  version = '0.0.1-SNAPSHOT'
  sourceCompatibility = '11'
  
  //lombok 설정 추가 시작
  configurations {
     compileOnly {
        extendsFrom annotationProcessor
    }
  }
  //lombok 설정 추가 끝
  
  repositories {
      mavenCentral()
  }
  
  dependencies {
     implementation 'org.springframework.boot:spring-boot-starter'
     
     //lombok 라이브러리 추가 시작
     compileOnly 'org.projectlombok:lombok'
     annotationProcessor 'org.projectlombok:lombok'
     
     testCompileOnly 'org.projectlombok:lombok'
     testAnnotationProcessor 'org.projectlombok:lombok'
     //lombok 라이브러리 추가 끝
     
     testImplementation('org.springframework.boot:spring-boot-starter-test') {
         exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
     }
  }
  
  test {
   useJUnitPlatform()
  }
  ```
  
## 1. 객체 지향 설계와 스프링
  
### 1-1. 스프링의 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - **객체 지향 언어**
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

### 1-2. 객체 지향 특징
- 추상화
- 캡슐화
- 상속
- **다형성**

### 1-3. 역할과 구현을 분리
- **역할**과 **구현**으로 구분하면 세상이 **단순**해지고, **유연**해지며 **변경**도 편리해진다.
- 장점
  - **클라이언트**는 대상의 역할(인터페이스)만 알면 된다.
  - **클라이언트**는 구현 대상의 **내부 구조를 몰라도** 된다.
  - **클라이언트**는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않는다.
  - **클라이언트**는 구현 **대상 자체를 변경**해도 영향을 받지 않는다.

- 자바 언어의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

### 1-4. 스프링과 객체 지향
- **다형성**이 가장 중요하다!
- 스프링에서 제어의 역전(loC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 구현을 편리하게 변경할 수 있다.

## 2. 비지니스 요구사항과 설계
- 회원
  - 회원을 가입하고 조회할 수 있다.
  - 회원은 일반과 VIP 두 가지 등급이 있다.
  - 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
  
- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있다.
  - 회원 등급에 따라 할인 정책을 적용할 수 있다.
  - 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
  - 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다.(미확정)
 
 **주문과 할인 정책은 인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계한다.**
 
 ### 2-1. 회원 도메인 설계
- 회원 도메인 요구사항
  - 회원을 가입하고 조회할 수 있다.
  - 회원은 일반과 VIP 두 가지 등급이 있다. (enum 사용)
  - 회원 데이터는 제차 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)   

### 2-2. 회원 도메인 개발
##### 회원 엔티티
```
package hello.core.member;

public class Member {
    private Long id;
    private String name;
    private Grade grade;
    
    //생성자
    public Member(Long id, String name, Grade grade) {
        this.id = id;
        this.name = name;
        this.grade = grade;
    }

    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public Grade getGrade() {
        return grade;
    }
    public void setGrade(Grade grade) {
        this.grade = grade;
    }
}
```

##### 회원 저장소 인터페이스
```
package hello.core.member;

public interface MemberRepository {
    void save(Member member);

    Member findById(Long memberId);
}
```

##### 메모리 회원 저장소 구현체
```
package hello.core.member;

import java.util.HashMap;
import java.util.Map;

public class MemoryMemberRepository implements MemberRepository {

    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}
```

##### 회원 서비스 인터페이스
```
package hello.core.member;

public interface MemberService {
    void join(Member member); // 가입
    Member findMember(Long memberId); // 조회
}
```

##### 회원 서비스 구현체
```
package hello.core.member;

public class MemberServiceImpl implements MemberService{
    private final MemberRepository memberRepository = new MemoryMemberRepository();
    
    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

### 2-3. 회원 도메인 실행과 테스트
**JUnit 테스트 사용**

```
package hello.core.member;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class MemberServiceTest {
 MemberService memberService = new MemberServiceImpl();
 
 @Test
 void join() {
   //given 주어졌을 때
   Member member = new Member(1L, "memberA", Grade.VIP);
   
   //when 이렇게 했을 때
   memberService.join(member);
   Member findMember = memberService.findMember(1L);
   
   //then 이렇게 된다
   Assertions.assertThat(member).isEqualTo(findMember);
   }
}
```

이 코드의 문제점 : 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음  
**인터페이스 = new 구현체**

### 2-4. 주문과 할인 도메인 설계
- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있다.
  - 회원 등급에 따라 할인 정책을 적용할 수 있다.
  - 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
  - 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

### 2-5. 주문과 할인 도메인 개발
##### 할인 정책 인터페이스
```
public interface DiscountPolicy {
	/*
	 * @return 할인 대상 금액
	 */
	int discount(Member member, int price);
}
```

##### 정액 할인 정책 구현체
```
@Component
public class FixDiscountPolicy implements DiscountPolicy{

	private int discountFixAmount = 1000; // 1000원 할인
	
	@Override
	public int discount(Member member, int price) {
		if(member.getGrade() == Grade.VIP) { // vip일때만 1000원 할인, enum은 == 사용
			return discountFixAmount;
		} else {
			return 0;
		}
	}
}
```
VIP면 1000원 할인, 아니면 할인 없음

##### 주문 서비스 인터페이스
```
public interface OrderService {
	Order createOrder(Long memberId, String itemName, int itemPrice); // 주문생성
}
```

##### 주문 서비스 구현체
```
public class OrderServiceImpl implements OrderService{
  private final MemberRepository memberRepository = new MemoryMemberRepository();
  private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
  
@Override
	public Order createOrder(Long memberId, String itemName, int itemPrice) {
		Member member = memberRepository.findById(memberId); // 회원정보 조회
		int discountPrice = discountPolicy.discount(member, itemPrice);
		
		return new Order(memberId, itemName, itemPrice, discountPrice);
	}
 }
```
주문 생성 요청이 오면, 회원 정보를 조회하고, 할인 정책을 적용한 다음 주문 객체를 생성해서 반환한다.
**메모리 회원 리포지토리와, 고정 금액 할인 정책을 구현체로 생성한다**

##### 주문과 할인 정책 테스트
**JUnit 테스트 사용**
```
MemberService memberService = new MemberServiceImpl();
OrderService orderService = new OrderServiceImpl();

@Test
void createOrder(){
    Long memberId = 1L;
    Member member = new Member(memberId, "pitchu", Grade.VIP);
    memberService.join(member);

    Order order = orderService.createOrder(memberId, "pitchu",10000);
    Assertions.assertThat(order.getDiscountPrice()).isEqualTo(1000);
}
```

## 3. 새로운 할인 정책 개발
기존 정책은 VIP가 10000원을 주문하든 20000원을 주문하든 항상 1000원을 할인했는데,   
이번에 새로 나온 정책은 10%로 지정해두면 10000원 주문시 1000원을 할인해주고, 20000원 주문시에 2000원을 할인해준다.   

##### 정률 할인 정책 구현체
```
public class RateDiscountPolicy implements DiscountPolicy {

	private int discountPercent = 10; // 할인율
	
	@Override
	public int discount(Member member, int price) {
		if(member.getGrade() == Grade.VIP) {
			return price * discountPercent / 100;
		} else {
			return 0;
		}
	}
}
```

##### 주문과 할인 정책 테스트
**JUnit 테스트 사용**
```
public class RateDiscountPolicyTest {
	
	RateDiscountPolicy discountPolicy = new RateDiscountPolicy();
	
	@Test
	@DisplayName("VIP는 10% 할인이 적용되어야 한다")
	void vip_o() {
		// given
		Member member = new Member(1L, "memberVIP", Grade.VIP);
		// when
		int discount = discountPolicy.discount(member, 10000);
		// then
		assertThat(discount).isEqualTo(1000);
	}
	
	@Test
	@DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다")
	void vip_x() {
		// given
		Member member = new Member(1L, "memberBASIC", Grade.BASIC);
		// when
		int discount = discountPolicy.discount(member, 10000);
		// then
		assertThat(discount).isEqualTo(0);
	}
}
```

### 3. 새로운 할인 정책 적용과 문제점
할인 정책을 변경하려면 클라이언트인 OrderServiceImpl 코드를 고쳐야 한다.
```
public class OrderServiceImpl implements OrderService{

    //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
    private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
}
```
**문제점 발견**
1. DIP 문제
   OrderServiceImpl이 DiscountPolicy 인터페이스 뿐만 아니라 FixDiscountPolicy에도 의존하고 있다.  
   -> 추상(인터페이스)뿐만 아니라 구체(구현) 클래스에도 의존하고 있다.
2. OCP 위반
   지금 코드는 기능을 확장해서 변경하면, 클라이언트 코드에 영향을 준다.
   
**문제 해결 방법**  
DIP를 위반하지 않도록 인터페이스에만 의존하도록 설계를 변경하자

```
//private final DiscountPolicy discountPolicy = new FixDiscountPolicy(); -> X
//private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); -> X

private final DiscountPolicy discountPolicy; -> O
```

**추가 문제**  
구현체가 없어서 실제 실행을 해보면 NPE(null pointer exception)가 발생한다.

**해결방안**  
누군가가 클라이언트인 orderServiceImpl에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해주어야 한다.


